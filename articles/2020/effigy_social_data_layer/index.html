<!doctype html><html><head><title>Effigy, a distributed social data layer</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet href=../../../css/theme.css><link rel=stylesheet href=../../../css/syntax.css><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-56296045-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script async defer data-domain=willschenk.com src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Effigy, a distributed social data layer"><meta property="og:description" content="I grew up in the world of BBSes, Usenet, and, to some extent, UUCP before that. This was fun – a world wide network all built up by volunteers sharing. Since we are all carrying supercomputers around now with massive idle storage and bandwidth, let's think about how we can recreate some of that fun, independent data sharing with modern web technologies, specifically Websockets and WebRTC. All you need is the computer that you already have with you."><meta property="og:type" content="article"><meta property="og:url" content="https://willschenk.com/articles/2020/effigy_social_data_layer/"><meta property="article:published_time" content="2020-07-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Effigy, a distributed social data layer"><meta name=twitter:description content="I grew up in the world of BBSes, Usenet, and, to some extent, UUCP before that. This was fun – a world wide network all built up by volunteers sharing. Since we are all carrying supercomputers around now with massive idle storage and bandwidth, let's think about how we can recreate some of that fun, independent data sharing with modern web technologies, specifically Websockets and WebRTC. All you need is the computer that you already have with you."><meta name=twitter:site content="@wschenk"><style>.article p,.article ul,.article ol,.article table{max-width:45em}.article pre p{max-width:none;margin-top:-1.5rem}article.article p:first-child,.article blockquote{font-size:1.25em;font-weight:300;max-width:36em}.half-height-scroll{max-height:32em;overflow:scroll}</style></head><body><nav class="container my-5"><h1 class="pt-md-5 display-3"><a class=text-dark href=../../../>Will Schenk</a></h1><p><a class="text-dark h4 mr-3 font-weight-light" href=../../../articles/>Articles</a>
<a class="text-dark h4 mr-3 font-weight-light" href=../../../contact>Contact</a>
<a class="text-dark h4 mr-3 font-weight-light" href=../../../tags/>Tags</a>
<a href=../../../feed.xml class="mr-3 h4 text-light"><img src=../../../img/rss.svg alt=rss height=20 width=20></a>
<a href=https://twitter.com/@wschenk class="mr-3 h4 text-light"><img src=../../../img/twitter.svg alt=twitter height=20 width=20></a>
<a href=https://instagram.com/wschenk class="mr-3 h4 text-light"><img src=../../../img/instagram.svg alt=instagram height=20 width=20></a>
<a href=https://github.com/wschenk class="mr-3 h4 text-light"><img src=../../../img/github.svg alt=github height=20 width=20></a>
<a href=https://linkedin.com/in/will-schenk-420266 class="mr-3 h4 text-light"><img src=../../../img/linkedin.svg alt=linkedin height=20 width=20></a></p></nav><div class=container><h1 class=mt-5>Effigy, a distributed social data layer</h1><h2 class="font-weight-light font-italic mb-3">Scuttlebutt is awesome, let&rsquo;s run with it</h2><p class="text-muted mt-3"><a class=text-muted href=https://willschenk.com/articles/2020/effigy_social_data_layer/>Published July 3, 2020</a>
<a class=text-muted href=../../../tags/p2p>#p2p,</a>
<a class=text-muted href=../../../tags/design>#design,</a>
<a class=text-muted href=../../../tags/overview>#overview,</a>
<a class=text-muted href=../../../tags/serverless>#serverless,</a>
<a class=text-muted href=../../../tags/websockets>#websockets,</a>
<a class=text-muted href=../../../tags/webrtc>#webrtc,</a>
<a class=text-muted href=../../../tags/effigy>#effigy</a></p><article class="article mt-5"><p>I grew up in the world of BBSes, Usenet, and, to some extent, UUCP before
that. This was fun – a world wide network all built up by volunteers
sharing. Since we are all carrying supercomputers around now with
massive idle storage and bandwidth, let's think about how we can
recreate some of that fun, independent data sharing with modern web
technologies, specifically Websockets and WebRTC. All you need is
the computer that you already have with you.</p><h2 id=headline-1>Abstract</h2><p>We're going to take a lot of concepts from what's been done before and
remix them all. Here are some of the specific projects and ideas that
I was inspired by – I have no idea which came first in the history of
things, but this reflects my journey.</p><ul><li><p>From <a href=https://en.wikipedia.org/wiki/UUCP>UUCP</a> we will take the idea that you store data on your
"neighbors", can request functionality from other connections, and
need no centralizing authority.</p></li><li><p>From <a href="https://www.youtube.com/watch?v=Ng0NE4lDP2U">Fidonet</a> we try and vibe off of the energy of <a href=https://en.wikipedia.org/wiki/Tom_Jennings>Tom Jennings</a>, but
actually keep that anarcist spirit alive by avoiding all centralized
authority.</p></li><li><p>From <a href=https://scuttlebutt.nz/>Scuttlebutt</a> we will take identity-centric sharing, that
network block and sharing is reflective of real human networks, feed
posting, group encryption, "every client is a pub", and its
offline-first ideas.</p></li><li><p>From <a href=https://en.wikipedia.org/wiki/BitTorrent>BitTorrent</a> we take the concepts of stateless tracker servers
and in general distributed file-sharing.</p></li><li><p>From <a href=https://en.wikipedia.org/wiki/Blockchain>Blockchain</a> we take the idea that the system has rules for
accepting feeds, and that you could memorize your private key
with a word sentence mnenomic.</p></li><li><p>From <a href=https://ipfs.io/>ipfs</a> we will take the idea that content is self-signing,
content blobs can be Merkle trees of directories, and that it needs
to run as a Javascript user process in the browser.</p></li><li><p>From <a href=https://dat.foundation/>dat</a> we take some of the ideas of being able to update on a key
that is shared around.</p></li><li><p>From <a href=https://syncthing.net/>syncthing</a> the idea of mutually signing your devices to setup
file mirroring, also passing keys around with QR scodes.</p></li><li><p>From <a href=https://docsend.com/view/gu3ywqi>textile threads</a> we take the ideas of feed-read keys vs content-read keys.</p></li><li><p>From <a href=https://web.dev/progressive-web-apps/>Progressive Web Apps</a> we take the idea that it's easy to deploy and
install on your device without going through gatekeepers, that we
expect storage to be ephemeral, and multiple devices go to the same
account.</p></li></ul><p>In terms of intellectual heritage this follows primarily from
<a href=https://scuttlebutt.nz/docs/principles/>Scuttlebutt's principles</a> and <a href=https://handbook.scuttlebutt.nz/stories/design-challenge-avoid-centralization-and-singletons>Scuttlebutt's no centralization and no
singletons</a> – so a huge shoutout to <a href=https://dominictarr.com/>Dominic Tarr</a> – and then trying to
apply the concepts so that it can work on regular browsers.</p><p>Much of the following document will try to work around the strengths
and weaknesses of browsers – specifically that they are the best
application platform since everyone has access to them, that they
don't accept incoming connections, and that they don't provide very
good presistent storage guarantees. The ideas of <code class=verbatim>ssb</code> and <code class=verbatim>dat</code> are
great, but they don't work in browsers. No <a href=https://www.electronjs.org/>electron</a> or JavaScript
unsupported by browsers here.</p><p>Also, let's recognize that all of this doesn't need to be so
complicated. If we can relax some restrictions, getting things close
is good enough. If you assume that people have multiple devices, they
ensure that their data is both on their phone and their laptop, and
their friend's phone and friend's laptop ,and then you don't need to
go through all of these crazy incentive systems that you get with
Textile or Filecoin. There's no highlevel incentive for BitTorrent and
that seems to be doing just fine. We are <em>sharing things with friends</em>
here, that's the mindset.</p><p>In a situation where all your devices explode at the same time you can
just check in with your actual social network to recover from a
disaster, just like real life.</p><h2 id=headline-2>Design</h2><h3 id=headline-3>Content addressable</h3><p>Every bit of content is named by its signature, so therefore the data
doesn't live anywhere. The private key is the only special
information, and perhaps this could be a mnenomic like "memorize your
bitcoin wallet address with this weird sentence thing."</p><p>Machines connect, cache, and share the data that they have. Like NNTP,
it starts out with a IWANT and IHAVE negotiation to get the heads, and
then pulls stuff down as needed.</p><p>Larger blobs are stored the same way, so there's an underlying object
cloud there. Blob size is shared as part of the protocol, so when
available blobs are announced you know how big it is.</p><h3 id=headline-4>Identity</h3><p>Identity is the public key, which is generated on startup. There is a
private key that signs every bit of data you put in the system
and you "are" your public key.</p><p>When communicating with other devices, you will generally annouce an
<code class=verbatim>[identity,head]</code> pair. The head is the "latest" entry in a chain based
on its ID. This ID could be the time signature, but since only one
device can create an entry (since entries are signed by the private
key they can't be forged) there's no need for synchronization.</p><h3 id=headline-5>Entries</h3><p>Entries are a JSON string followed by a signature, or they are an
encrypted object.</p><p>The payload of an entry is either a JSON string, or an encrytped
string.</p><p>The key of the entry is the hash of the full entry, including the
signature.</p><p>Each entry JSON object contains:</p><table class="table table-striped"><tbody><tr><td>identity</td><td>of the signer of the blob</td></tr><tr><td>parent</td><td>pointer to parent entity</td></tr><tr><td>comparable</td><td>like an id or timestamp, must be positive integer</td></tr><tr><td>synod</td><td>[identity,head] of synod</td></tr><tr><td>payload</td><td>see below</td></tr></tbody></table><p><em>(Synod <a href=Synods>described below</a> but in short is the account concept that groups
devices together and lists current signalling servers and dropboxes.)</em></p><p>When you get an entity, you first figure out if it's valid – first
by checking to see if the blob hashes to the blob name, and secondarily
to see if the identity is the signer of the message. If an entry is
announced as part of a <code class=verbatim>[identity,head]</code> pair then the inner and outer
identities are compared to see if they are identical, and the
operation is aborted if not.</p><p>Once the entity is valid, it goes on the <em>identity entry</em> list. This
list is sorted by <code class=verbatim>comparable</code>, and the highest number is considered to
be this node's version of <em>head</em> for that entity. This <code class=verbatim>identity</code> can
optionally go on the <em>identity watch list</em> which will be used to follow
information for this identity in the future.</p><h4 id=headline-6>Payload Types</h4><p><strong>DRAFT</strong></p><p>Payloads have different types, and ultimately reference larger
blobs in the network.</p><table class="table table-striped"><tbody><tr><td>synod</td><td>synod data object</td></tr><tr><td>identification</td><td>json with name, about, whatever</td></tr><tr><td>public_note</td><td>note to the world</td></tr><tr><td>private_note</td><td>note to people with readkeys</td></tr><tr><td>image</td><td>pointer to image blob</td></tr><tr><td>collection</td><td>pointer to archive of blobs</td></tr><tr><td>tag</td><td>marking an entry in some way</td></tr><tr><td>comment</td><td>make a comment to on an entry</td></tr><tr><td>follow</td><td>you announce that you are following a feed</td></tr><tr><td>block</td><td>you tell the system you no longer are tracking and sharing an identity</td></tr><tr><td>mute</td><td>encrypted block that pretends not to know anything</td></tr></tbody></table><h4 id=headline-7>References</h4><p>Referencing other entries are to its hash, which contains a pointer to
the identity and the synod. Both the identity and the synod can be
referenced with the blob request mechanism. Once these are loaded,
the system then uses the <code class=verbatim>[identity,head]</code> from the signalling server or
connected clients to reconstruct the feed, whose entries are validated
using the signatures.</p><p>References are not to the feed itself, but to an entry on the feed.
So it's possible to find references to an entity, locate the last
version of its feed, but not find the original entity on it. This
would be in the scenario where a user deleted an entry for their feed,
and all the subsequent items needed to be rewritten and
republished. This will break references to that <code class=verbatim>entity</code> and <em>all
following entity</em> so change the past with care.</p><h3 id=headline-8>Synods</h3><p>Synods are a special type of <code class=verbatim>identity</code> that is used to</p><ol><li><p>collect identities together</p></li><li><p>publish frequented singalling servers</p></li><li><p>publish dropboxes monitored</p></li><li><p>summarize profile information</p></li></ol><p>An <code class=verbatim>identity</code> is part of a <code class=verbatim>synod</code></p><ul><li><p><code class=verbatim>identity</code> has signed the <code class=verbatim>synod public key</code> in an entry signed by the
<code class=verbatim>synod</code>'s private keys</p></li><li><p>there is not a <em>identity revoked entry</em> in the <code class=verbatim>synod</code>'s feed</p></li></ul><p>From a User Interface perspective then a <code class=verbatim>synod</code> should be considered as
the <em>profile</em> of the user, and the latest information here should be the
avatar and display name. <code class=verbatim>follow</code> messages can be posted in device
identity streams or <code class=verbatim>synod</code> streams which implies that you can choose
what to replicate depending on which device you are using.</p><p>All <code class=verbatim>identities</code> of a <code class=verbatim>synod</code> are expected to mutually replicate, so in
the case that you do lose your device/key you'll be able to recover
all of your information.</p><p>A group of <em>signalling servers</em> are published with the <code class=verbatim>synod</code>, so if you
want to send a message to that user or be able to sync up their latest
<code class=verbatim>head</code> you have a place to start.</p><p>Some <em>signalling servers</em> can optionally accept incoming drop
messages. This is an <code class=verbatim>[target_identity,identity,entry]</code> tuple that is
marked as targeting a specific <code class=verbatim>target_dentity</code> (or <code class=verbatim>synod</code>) so you can
contact other people on the network if they aren't already following
you.</p><p>The User Interface is expected to highlight incoming messages for
non-followed identites that you can choose to read, acknowledge, reply
or ignore. There is no confirmation mechanism for the sender to know
that the message has been received without user action.</p><p>Synods are basically another type of feed that contains pointers to
shared identities, a list of used signal servers, and profile
information. They're designed to work around "losing your private key is
losing your identity" and it provides a way to publish changes for
super old entiries whose <code class=verbatim>identities</code> aren't being shared anymore.</p><h3 id=headline-9>Feeds</h3><p>Every entry is a json <code class=verbatim>blob</code> which points to its previous <code class=verbatim>blob</code>. The key
of the <code class=verbatim>blob</code> is its hashkey, so that you can ask for a key and verify
that the data is correct. It doesn't matter who or where you get the
data from.</p><p>All entries are signed by the public key of the identity, so you know
that it's from the same private key.</p><h4 id=headline-10>Valid feeds</h4><p>Invalid feeds don't propogate</p><ol><li><p>Feeds that are too large for the network to propagate. (e.g. you can
post a link to a movie but not the movie itself)</p></li><li><p>Feeds that contain invalidly signed entries</p></li><li><p>Feeds that contain unencryted images with exif data</p></li><li><p>Feeds that have a revoked public key (i.e. last valid id was x
everything after that is wrong)</p></li></ol><h4 id=headline-11>Heads</h4><p>Each node keeps track of identities and heads, which is the latest
entry. When a node connects, it announces all of the identities that
are tracked, and what latest head it has. Nodes can then share
and request heads, and if they have the feed read keys they can trace
things backwards to get to the root.</p><h3 id=headline-12>Multiencryption</h3><p>How does SSB have messages that multiple people can decrypt? <a href=https://ssbc.github.io/scuttlebutt-protocol-guide/#encrypting>It's
documented here</a>, but I don't understand it yet.</p><h3 id=headline-13>Feed</h3><p>Everyone has a head, which is the latest that the feed has. Each
entry is a type and a pointer to a previous feed.</p><p>Deletion is done with rebasing, which means that you are able to
rewrite your feed. So content that you address for commenting or
whatever needs to be separate from the feed itself, and in theory you
could comment upon a feed entry that is missing from the head. These
orphaned contents will always point to an identity, and the datablobs
are the same, but may not be discoverable.</p><h3 id=headline-14>Drop Box</h3><p>Some singalling servers provide a <em>dropbox</em> service, which allows blobs
to be stored and shared on a server for a finite period of time and
offered up to every client that connects to the server. These are
expected to be multiencrypted with the <code class=verbatim>synod</code>'s public key and perhaps
with the sub-<code class=verbatim>identities</code> key so the recipient is obscured.</p><p>The <code class=verbatim>synod</code> should announce endpoints that it uses for signalling and
where it potentially receives messages.</p><p>The system should pull down messages from the inboxes – which
can be public places that automatically delete everything after 14
days or whenever – and then you can choose to pull something down or
not. Entries are meant to be small but can point to larger blobs.</p><h2 id=headline-15>Protocol</h2><p>The protocol exchanges JSON messages over a reliable transport that
delivers complete, discrete messages. Initial implementation targets
websockets and WebRTC data transport.</p><p>When a node to node connection is established – using WebSockets to a
well known address for example – a session is created between the two
nodes. This is done by <em>node a</em> generating a random string and <em>node b</em>
signing it, and <em>node b</em> generating a random string and <em>node a</em> signing
it. Once done, both nodes know that the other is in possession of the
private key that matches their public key.</p><p>Nodes then announce which services they are willing to provide to each
other, which could be a subset of the full set of services
provided for trusted <code class=verbatim>identities</code>.</p><h3 id=headline-16>Services</h3><p>Each client is able to provide services for other ones outside of blob
propogation, which all clients are required to provide, though they
have no requirement for any data persistency. (In other words, you need
to be able to serve up at least blob referencing your identity and
things you choose, but don't need to serve anything you don't have or
want to share.)</p><table class="table table-striped"><tbody><tr><td>Service</td><td>Description</td></tr><tr><td>blobs</td><td>Blob sharing</td></tr><tr><td>headtracking</td><td>remembers the latest head for identities</td></tr><tr><td>signalling</td><td>Network presence</td></tr><tr><td>relaying</td><td>passing data to a mutually connection not directly</td></tr><tr><td>dropbox</td><td>Receives and forwards requests from unknown identities</td></tr><tr><td>data lease</td><td>Storing of blobs with some guarentees</td></tr><tr><td>voice</td><td>Voice calling</td></tr><tr><td>video</td><td>Video calling</td></tr></tbody></table><h4 id=headline-17>Blob sharing</h4><p>Every bit of data in the system is stored as a key pair, with the key
being the cryptographic hash of the data. This blob could be an
<code class=verbatim>entities</code> which contains metadata to describe itself; a signature and a
link to a blob containing the public key signing it, and a link to a
<code class=verbatim>synod</code> which is the account that is associated with the <code class=verbatim>identity</code>.</p><p>When a client connects, it notifies the other side which blobs it's
interested in, and other other side says which blobs it has.</p><h4 id=headline-18>Signalling</h4><p>Signalling is a way to broadcast to other nodes the your latest
<code class=verbatim>[identity,head]</code> pair and as a way to coordinate <code class=verbatim>WebRTC</code> connections.
If two clients are connected over <code class=verbatim>Websockets</code> to the same singalling
server they can exchange messages directly, which allows for <code class=verbatim>offer</code> and
<code class=verbatim>answer</code> <code class=verbatim>SDP</code> messages to make initial contact with a node that doesn't
allow incoming connections (i.e. web browsers) and then will be able
to coordinate the connection through a <code class=verbatim>STUN</code> server.</p><p>Providing this service requires a DNS name and an externally
accessible IP address, though probably not a huge amount of data
(unless it's also caching and storing a lot of blobs). Additional
directory and other services could be worth paying for.</p><h4 id=headline-19>Relaying</h4><p>Relaying moving data through this system if the two nodes can't
connect directly. I'm envisioning having a <code class=verbatim>coturn</code> instance acting as a
<code class=verbatim>TURN</code> server that understands the <code class=verbatim>identity</code> as authentication.</p><p>Providing this service requires bandwidth and an externally accessible
IP, so it's logical to charge money for this.</p><h4 id=headline-20>Dropbox</h4><p>This node receives messages for another user for situations where the
recipient has no knowledge of the sender and therefore no reason to be
tracking their identity. The next time the recipient connects to this
signalling server, it will see the message.</p><p>Signalling services that the recipient has requested as a dropbox are
published as part of their synod, so you'll need that in order to
direct a message to them.</p><h4 id=headline-21>Data Leasing</h4><p>Data leasing is a quest for the node to store an identities data for
at least a certain period of time, to make it accessible to the
network when the original device is offline. This is similar to a pinning
service in <a href=IPFS>IPFS</a>.</p><p>One scenario is that all of the <code class=verbatim>identities</code> in a <code class=verbatim>synod</code> provide mutual
data leasing, which means that your data is backed up on all of your
devices. You could lose everything less 1 and still be able to
recreate the graph.</p><p>Another scenario is that you provide leasing to trusted friends, the
sort of people you give spare house keys to, so that if either of you
have a catastrophic failure you can reconstruct everything. (Some
provision for recovering lost <code class=verbatim>synod</code> private keys would need to be
thought out.)</p><p>A third example is providing data leasing as a service, which would be
something that you could charge for.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width
clienta-&gt;clientb: wantservice(sessiontoken)
clientb-&gt;clienta: providesservice(sessiontoken)
clienta-&gt;clientb: call(service,datalease,head)</code></pre></div><p><img src=services.png alt=services.png title=services.png></p><h4 id=headline-22>Voice and Video</h4><p>If both <code class=verbatim>identities</code> are mutually trusted and on a <em>permitted contact
list</em> then they can use the WebRTC mechanisms to have real time
communication. I'm not sure how well push notifications really work
over progressive web apps, but seems worth exploring since we already
are connecting over WebRTC.</p><h3 id=headline-23>Request Sequences</h3><h4 id=headline-24>Startup</h4><p>When a client starts up, it connects to the clients it knows about and
is able to reach. It first announces the service that it provides to
the network, in the case it has a list of identity heads and can store
blobs.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

client1 -&gt; client2 : sessionrequest[identity1,head1,challenge1]
client2 -&gt; client1 : sessionrequest[identity2,head2,challenge2]
client1 -&gt; client2 : sessionauth[signed(identity1,challenge2)]
client2 -&gt; client1 : sessionauth[signed(identity2,challenge1)]</code></pre></div><p><img src=startup.png alt=startup.png title=startup.png></p><p>If either of the signatures don't match, then the session is considered
unauthenticated.</p><p>If the signature matches, then the head announced is considered to be
the head of the respective identity. <em>Note that it not a requirement
that a head tracking service downloads and verifies the head</em></p><h4 id=headline-25>Service Discovery</h4><p>After authentication the clients exchange the list of services they
are willing to provide to the other.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

client1 -&gt; client2 : provides[service_list]
client2 -&gt; client1 : provides[service_list]</code></pre></div><p><img src=service.png alt=service.png title=service.png></p><p><strong>TODO</strong> There needs to be a way for the client to request access to an
additional service.</p><h4 id=headline-26>Head Tracking</h4><p>Here one side sends a <code class=verbatim>get_heads</code> request for its <em>identity watch list</em>.
The other returns with a list of <code class=verbatim>[identity,head]</code> pairs for <code class=verbatim>identities</code>
that it knows about.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

client1 -&gt; client2 : getHeads([identities])
client2 -&gt; client1 : lastKnownHeads([identities,heads])</code></pre></div><p><img src=head_tracking.png alt=head_tracking.png title=head_tracking.png></p><h4 id=headline-27>Signalling</h4><p>Signalling is tracking presence and helping to coordinate connections
between devices (i.e. start of the WebRTC handshake).</p><h5 id=headline-28>Presence</h5><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

client -&gt; signalserver : online
signalserver -&gt; otherclients : online(identity,head)
signalserver -&gt; client : presence_list(identities)
client -&gt; signalserver : &lt;disconnect&gt;
signalserver -&gt; otherclients : offline(identity)</code></pre></div><p><img src=signalling.png alt=signalling.png title=signalling.png></p><h5 id=headline-29>Messaging</h5><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

client1 -&gt; signalserver : message_to(identity2,payload)
signalserver -&gt; client2 : message_from(identity1,payload)</code></pre></div><p><img src=messaging.png alt=messaging.png title=messaging.png></p><p>The signal server returns that it tracks presence, can forward
messages between clients, and also tracks identity heads. It is not
required to store blobs.</p><p>The client requests a list of heads for things on the <em>identity watch
list</em>, and the signalling server returns the union of what it knows
about and what the client is tracking.</p><p>The client then requests the presence list of clients connected to the
signalling server, and the signalling server returns a list of connected
clients with their heads. The server also announces to everyone else
that the client is connected.</p><p>At this point the client is ready to start connecting to other clients
through the signalling server.</p><h4 id=headline-30>Blobs</h4><p>Clients periodically send <em>iwant lists</em> to each other, returning the
blobs that it has or is willing to share (based on perhaps bandwidth,
if the client is operating on a battery, or over a metered celluar
connection).</p><p><strong>TODO</strong> Clients should track incoming blob requests and outgoing blog
bandwidth to create a leech ratio that takes into account sharing
reciprocity. Credit is created by sharing more or perhaps by
purchasing bandwidth from the remote server. The request is signed by
the identity so the clients can tell who is asking for what.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

clienta-&gt;clientb: iwant(blobs)
clientb-&gt;clienta: ihave(blobs)
clienta-&gt;clientb: getblob(blob,maxsize)
clientb-&gt;clienta: blob</code></pre></div><p><img src=blobpropgation.png alt=blobpropgation.png title=blobpropgation.png></p><p>Once the client is connected to a system, signal or client, it sends a
list of the blobs that it wants. Since these are content addressable
and signed by the identity, it doesn't matter where they come from.</p><p>A signal server may or may not have blobs – it's a regular client that
presumably is free of firewall and NAT messiness, and had the
additional feature of being able to relay requests.</p><h4 id=headline-31>Identity tracking</h4><p>The client looks through its list of identities, and all of the head
announcements that it's received. For each of these it tries to get
the blob associated with the head. Note that <code class=verbatim>synod</code> are also identities
so fall into this logic as well.</p><div class="src src-plantuml"><pre><code class=language-plantuml data-lang=plantuml>scale 800 width

(*) --&gt; &#34;Receive identity,head message&#34;

If &#34;tracking identity&#34; then
  --&gt;[Yes] &#34;get blob&#34;
else
  --&gt;[No] &#34;ignore&#34;
Endif

&#34;get blob&#34; If &#34;has blob&#34; then
  --&gt;[Yes] If &#34;decrypt blob&#34; then
    --&gt;[get parent] &#34;get blob&#34;
  else
    --&gt;[No] &#34;ignore&#34;
  Endif

else
  -&gt;[No] &#34;add to iwantlist&#34;
Endif

--&gt; (*)</code></pre></div><p><img src=flowchart.png alt=flowchart.png title=flowchart.png></p><h3 id=headline-32>Chain validity</h3><ol><li><p>All entries need to be less than 15K. TODO</p></li><li><p>All unencrypted entries to photos must not have location data.</p></li><li><p>All head requests with an synod identity with a final head must be
marked invalid.</p></li></ol><h2 id=headline-33>State</h2><ol><li><p>First pass at technical design - Done</p></li><li><p>Prototyping started - 2020-07-03</p></li></ol><h2 id=headline-34>Comments</h2><p>I can be reached at <a href=https://twitter.com/wschenk>@wschenk</a>, @wschenk@floss.social, and wschenk@gmail.com</p></article></div><div class="bg-light py-5"><div class=container><h2 class=text-center>Read next</h2><div class=row><div class="col-md-6 text-center">Next Post:
<a href=../../../articles/2020/setting_up_ssb_pub_server/>Setting up SSB-Pub Server</a></div><div class="col-md-6 text-center">Previous Post:
<a href=../../../articles/2020/upgrading_emacs_on_debian/>Upgrading emacs on debian</a></div></div></div></div><footer class="footer bg-dark text-light mt-3"><div class=container><h2 class="py-5 font-weight-light my-0">Made in Brooklyn, NY.</h2></div></footer></body></html>