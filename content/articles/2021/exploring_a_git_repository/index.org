#+title: Exploring a git repository
#+title: git
#+date: 2021-03-24
#+draft: true

* Dockerfile

#+begin_src Dockerfile :tangle Dockerfile
FROM ruby:3.0.1

RUN apt-get update && apt-get install -y cloc libsqlite3-dev

WORKDIR /app

COPY Gemfile* ./
RUN bundle install

#COPY *.rb *sh ./
#RUN chmod +x *.sh *rb
#ENTRYPOINT "/app/entry_point.sh"

CMD bash
#+end_src

#+begin_src bash :tangle gitinfo
  export REPO=https://github.com/ruby-git/ruby-git
  mkdir -p output
  docker build . -t wschenk/gitinfo && \
      docker run --rm -it \
             -v $PWD/output:/output \
             -v $PWD:/app \
             --env REPO=$REPO \
             wschenk/gitinfo
#+end_src

#             -v $PWD:/app \

* =entry_point= Script

1. Checkout the repostory
2. Create the work directory
3. Run the scripts
   
#+begin_src bash :tangle entry_point.sh
  #!/bin/bash
  REPO_WORK_DIR=/repository
  WORK_DIR=/output

  if [ -d ${REPO_WORK_DIR} ]; then
     echo Using repo in ${REPO_WORK_DIR}
  else
      if [ -z "$REPO" ]; then
          echo Please set the REPO env variable or mount ${REPO_WORK_DIR}
          exit 1
      fi

      git clone $REPO ${REPO_WORK_DIR}
  fi

  if [ ! -d ${WORK_DIR} ]; then
      echo Creating ${WORK_DIR}
      mkdir -p ${WORK_DIR}
  fi


  # Create a log of commits
  #(cd ${REPO_WORK_DIR};git log --reverse --pretty='format:%aI|%ae|%an|%D') | sort > ${WORK_DIR}/commits.log

  # Create a list of authors
  #(cd ${REPO_WORK_DIR};git log --pretty=format:"%ae:%an") | sort -u > ${WORK_DIR}/authors.log

  # Create a log of commits with files
  (
      cd ${REPO_WORK_DIR}
      git log --pretty=format:'|%H|%ae|%an|%aI|%s' --numstat
  ) > ${WORK_DIR}/commits_with_files.log

  # Create a list of tags
  (
      cd ${REPO_WORK_DIR}
      git tag --sort=-v:refname --format='%(refname:short):%(objectname):%(*objectname):%(creatordate:iso8601-strict)'
  ) > ${WORK_DIR}/tags.log

  cd ${WORK_DIR}

  for i in /app/*rb; do
      ruby $i
  done
#+end_src

* Files

We'll need a =Gemfile= to include for the sqlite3 gem.

#+begin_src ruby :tangle Gemfile
  # frozen_string_literal: true

  source "https://rubygems.org"

  git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }

  gem "sqlite3", "~> 1.4"
#+end_src

* Commits

Lets first populate the database with all of the commits, and files
associated with those commits.

This works off a file created with

#+begin_src bash
  git log --pretty=format:'|%H|%ae|%an|%aI|%s' --numstat
#+end_src

#+begin_src ruby :tangle commits.rb
  require 'sqlite3'

  def create_database filename
    db = SQLite3::Database.new filename

    rows = db.execute <<-SQL1
         CREATE TABLE IF NOT EXISTS commits (
                id	TEXT UNIQUE,
                summary	TEXT,
                author_name	TEXT,
                author_email	TEXT,
                author_when	DATETIME
                );
  SQL1

    rows = db.execute <<-SQL2
         CREATE TABLE IF NOT EXISTS commit_files (
                id    TEXT,
                name  TEXT,
                added INT,
                deleted INT
                );
  SQL2

    db
  end

  def add_commit db, id, email, name, date, summary
    ret = db.execute("INSERT INTO commits (id, summary, author_name, author_email, author_when)
          VALUES (?, ?, ?, ?, ?)", [id, summary, name, email, date ] )
  end

  def add_file_commit db, id, file, added, deleted
    ret = db.execute("INSERT INTO commit_files (id, name, added, deleted)
          VALUES (?, ?, ?, ?)", [id, file, added, deleted] )

  end

  def parse_file db, file
    commit = nil
    File.open( file ).each_line do |line|
      line.chomp!
      if line[0] == '|'
        md = /\|(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*)/.match( line )
        commit = md[1]

        puts line

        begin
          add_commit db, md[1], md[2], md[3], md[4], md[5]
        rescue SQLite3::ConstraintException
          puts "Found existing commit, exiting"
          exit
        end
      elsif line.length != 0
        md = /([\d|-]*)\s*([\d|-]*)\s*(.*)/.match( line )
        add_file_commit db, commit, md[3], md[1], md[2]
      end
    end
  end

  db = create_database "commits.db"
  db.transaction
  parse_file db, "commits_with_files.log"
  db.commit
#+end_src

* Tags

Now lets populate the tag information.  We are banking on the idea
that a lot of projects will automatically tag a release as part of
their build scripts.

This file is created with:

#+begin_src bash
  git tag --sort=-v:refname --format='%(refname:short):%(objectname):%(*objectname):%(creatordate:iso8601-strict)'
#+end_src

#+begin_src ruby :tangle tags.rb
  require 'sqlite3'

  def create_database filename
    db = SQLite3::Database.new filename

    rows = db.execute <<-SQL1
         CREATE TABLE IF NOT EXISTS tags (
                name TEXT UNIQUE,
                sha TEXT,
                object TEXT,
                created_at DATETIME
                );
  SQL1

    return db
  end

  def add_tag db, name, sha, object, created_at
    ret = db.execute("INSERT INTO tags (name, sha, object, created_at)
              VALUES (?, ?, ?, ?)", [name, sha, object, created_at])
  end



  def parse_file db, file
    commit = nil
    File.open( file ).each_line do |line|
      line.chomp!
      md = line.match( /(.*?):(.*?):(.*?):(.*)/ )

      if( !md )
          puts "Unrecognized line #{line}"
      else
        tag_name = md[1]
        sha = md[2]
        sha_object = md[3] unless md[3] == "" # have annotated tags point to the main commit
        created_at = md[4]

        begin
          add_tag db, tag_name, sha, sha_object, created_at
        rescue SQLite3::ConstraintException
          puts "Found existing tag, exiting"
          exit
        end
      end
    end
  end

  db = create_database "commits.db"
  db.transaction
  parse_file db, "tags.log"
  db.commit
#+end_src

So if you wanted to find out who tagged what when you could use the query:

#+begin_src sql
  select id, name, summary, author_name, created_at
  from tags, commits
  where id=object or id=sha
  order by created_at desc;
#+end_src

* Finding authors
* Producing a timeline

* Source file types

#+begin_src bash
cd #{repository.workdir};cloc --skip-uniqueness --quiet --by-file --csv --git #{sha}

#+end_src
* References
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
# End:
